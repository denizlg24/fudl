/**
 * Hook managing the drawing state machine for annotation mode.
 * Handles pointer events, coordinate normalization, tool-specific drawing logic,
 * and undo/clear operations.
 */

import { useCallback, useEffect, useRef, useState } from "react";
import type { AnnotationElement, AnnotationTool } from "@repo/types";
import { clearCanvas, renderAnnotation } from "./annotation-renderer";

interface UseAnnotationCanvasOptions {
  canvasRef: React.RefObject<HTMLCanvasElement | null>;
  containerRef: React.RefObject<HTMLDivElement | null>;
  enabled: boolean;
}

interface TextInputBox {
  x: number;
  y: number;
  w: number;
  h: number;
  tailX: number;
  tailY: number;
}

interface UseAnnotationCanvasReturn {
  tool: AnnotationTool;
  setTool: (tool: AnnotationTool) => void;
  color: string;
  setColor: (color: string) => void;
  lineWidth: number;
  setLineWidth: (w: number) => void;
  elements: AnnotationElement[];
  undo: () => void;
  clear: () => void;
  isEmpty: boolean;
  /** Active text input box (drag-defined area for the speech bubble) */
  textInput: TextInputBox | null;
  /** Commit text at the current position */
  commitText: (text: string) => void;
  /** Cancel text input */
  cancelText: () => void;
}

export function useAnnotationCanvas({
  canvasRef,
  containerRef,
  enabled,
}: UseAnnotationCanvasOptions): UseAnnotationCanvasReturn {
  const [tool, setTool] = useState<AnnotationTool>("pen");
  const [color, setColor] = useState("#ef4444");
  const [lineWidth, setLineWidth] = useState(4);
  const [elements, setElements] = useState<AnnotationElement[]>([]);
  const [textInput, setTextInput] = useState<TextInputBox | null>(null);

  // Drawing state refs (don't need re-renders)
  const isDrawingRef = useRef(false);
  const currentStrokeRef = useRef<[number, number][]>([]);
  const shapeStartRef = useRef<{ x: number; y: number } | null>(null);

  // Stable refs for current tool settings
  const toolRef = useRef(tool);
  const colorRef = useRef(color);
  const lineWidthRef = useRef(lineWidth);
  const elementsRef = useRef(elements);
  const textInputRef = useRef(textInput);

  toolRef.current = tool;
  colorRef.current = color;
  lineWidthRef.current = lineWidth;
  elementsRef.current = elements;
  textInputRef.current = textInput;

  const getNormalized = useCallback(
    (e: PointerEvent): { nx: number; ny: number } | null => {
      const canvas = canvasRef.current;
      if (!canvas) return null;
      const rect = canvas.getBoundingClientRect();
      const nx = (e.clientX - rect.left) / rect.width;
      const ny = (e.clientY - rect.top) / rect.height;
      return { nx: Math.max(0, Math.min(1, nx)), ny: Math.max(0, Math.min(1, ny)) };
    },
    [canvasRef],
  );

  const redraw = useCallback(
    (extraElements?: AnnotationElement[]) => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      clearCanvas(ctx, canvas.width, canvas.height);

      // Collect extras: explicit extras + textInput preview bubble
      const all: AnnotationElement[] = [...elementsRef.current];
      if (extraElements) all.push(...extraElements);

      // Draw empty speech bubble preview while the text input is open
      const ti = textInputRef.current;
      if (ti && !extraElements) {
        all.push({
          type: "text",
          x: ti.x,
          y: ti.y,
          w: ti.w,
          h: ti.h,
          text: "",
          color: colorRef.current,
          fontSize: 0.02,
        });
      }

      renderAnnotation(ctx, all, canvas.width, canvas.height);
    },
    [canvasRef],
  );

  // Redraw when elements or textInput changes
  useEffect(() => {
    redraw();
  }, [elements, textInput, redraw]);

  // Clear canvas and state when disabled
  useEffect(() => {
    if (!enabled) {
      setElements([]);
      setTextInput(null);
      isDrawingRef.current = false;
      currentStrokeRef.current = [];
      shapeStartRef.current = null;
      const canvas = canvasRef.current;
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (ctx) clearCanvas(ctx, canvas.width, canvas.height);
      }
    }
  }, [enabled, canvasRef]);

  // Pointer event handlers
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !enabled) return;

    function onPointerDown(e: PointerEvent) {
      const pos = getNormalized(e);
      if (!pos) return;

      const currentTool = toolRef.current;

      isDrawingRef.current = true;
      canvas!.setPointerCapture(e.pointerId);

      if (currentTool === "pen") {
        currentStrokeRef.current = [[pos.nx, pos.ny]];
      } else {
        // arrow, circle, rectangle, and text all start with a drag origin
        shapeStartRef.current = { x: pos.nx, y: pos.ny };
      }
    }

    function onPointerMove(e: PointerEvent) {
      if (!isDrawingRef.current) return;
      const pos = getNormalized(e);
      if (!pos) return;

      const currentTool = toolRef.current;
      const c = colorRef.current;
      const w = lineWidthRef.current;

      if (currentTool === "pen") {
        currentStrokeRef.current.push([pos.nx, pos.ny]);
        const previewElement: AnnotationElement = {
          type: "stroke",
          points: [...currentStrokeRef.current],
          color: c,
          width: w,
        };
        redraw([previewElement]);
      } else if (shapeStartRef.current) {
        const start = shapeStartRef.current;
        let preview: AnnotationElement;

        if (currentTool === "arrow") {
          preview = {
            type: "arrow",
            startX: start.x,
            startY: start.y,
            endX: pos.nx,
            endY: pos.ny,
            color: c,
            width: w,
          };
        } else if (currentTool === "circle") {
          preview = {
            type: "circle",
            cx: start.x,
            cy: start.y,
            rx: Math.abs(pos.nx - start.x),
            ry: Math.abs(pos.ny - start.y),
            color: c,
            width: w,
          };
        } else if (currentTool === "text") {
          // Preview speech bubble shape during drag
          const x = Math.min(start.x, pos.nx);
          const y = Math.min(start.y, pos.ny);
          preview = {
            type: "text",
            x,
            y,
            w: Math.abs(pos.nx - start.x),
            h: Math.abs(pos.ny - start.y),
            text: "",
            color: c,
            fontSize: 0.02,
          };
        } else {
          // rectangle
          const x = Math.min(start.x, pos.nx);
          const y = Math.min(start.y, pos.ny);
          preview = {
            type: "rectangle",
            x,
            y,
            w: Math.abs(pos.nx - start.x),
            h: Math.abs(pos.ny - start.y),
            color: c,
            width: w,
          };
        }

        redraw([preview]);
      }
    }

    function onPointerUp(e: PointerEvent) {
      if (!isDrawingRef.current) return;
      isDrawingRef.current = false;
      canvas!.releasePointerCapture(e.pointerId);

      const pos = getNormalized(e);
      if (!pos) return;

      const currentTool = toolRef.current;
      const c = colorRef.current;
      const w = lineWidthRef.current;

      if (currentTool === "pen") {
        if (currentStrokeRef.current.length >= 2) {
          const newElement: AnnotationElement = {
            type: "stroke",
            points: [...currentStrokeRef.current],
            color: c,
            width: w,
          };
          setElements((prev) => [...prev, newElement]);
        }
        currentStrokeRef.current = [];
      } else if (shapeStartRef.current) {
        const start = shapeStartRef.current;

        // Ignore tiny accidental drags
        const dx = Math.abs(pos.nx - start.x);
        const dy = Math.abs(pos.ny - start.y);
        if (dx < 0.005 && dy < 0.005) {
          shapeStartRef.current = null;
          redraw();
          return;
        }

        if (currentTool === "text") {
          // Text tool: open the text input overlay instead of creating an element
          const bx = Math.min(start.x, pos.nx);
          const by = Math.min(start.y, pos.ny);
          // Enforce a minimum bubble size
          const bw = Math.max(dx, 0.12);
          const bh = Math.max(dy, 0.06);
          setTextInput({ x: bx, y: by, w: bw, h: bh });
          shapeStartRef.current = null;
          return;
        }

        let newElement: AnnotationElement;

        if (currentTool === "arrow") {
          newElement = {
            type: "arrow",
            startX: start.x,
            startY: start.y,
            endX: pos.nx,
            endY: pos.ny,
            color: c,
            width: w,
          };
        } else if (currentTool === "circle") {
          newElement = {
            type: "circle",
            cx: start.x,
            cy: start.y,
            rx: Math.abs(pos.nx - start.x),
            ry: Math.abs(pos.ny - start.y),
            color: c,
            width: w,
          };
        } else {
          // rectangle
          const x = Math.min(start.x, pos.nx);
          const y = Math.min(start.y, pos.ny);
          newElement = {
            type: "rectangle",
            x,
            y,
            w: Math.abs(pos.nx - start.x),
            h: Math.abs(pos.ny - start.y),
            color: c,
            width: w,
          };
        }

        setElements((prev) => [...prev, newElement]);
        shapeStartRef.current = null;
      }
    }

    canvas.addEventListener("pointerdown", onPointerDown);
    canvas.addEventListener("pointermove", onPointerMove);
    canvas.addEventListener("pointerup", onPointerUp);

    return () => {
      canvas.removeEventListener("pointerdown", onPointerDown);
      canvas.removeEventListener("pointermove", onPointerMove);
      canvas.removeEventListener("pointerup", onPointerUp);
    };
  }, [enabled, canvasRef, getNormalized, redraw]);

  const undo = useCallback(() => {
    setElements((prev) => prev.slice(0, -1));
  }, []);

  const clear = useCallback(() => {
    setElements([]);
    setTextInput(null);
  }, []);

  const commitText = useCallback(
    (text: string) => {
      if (!textInput || !text.trim()) {
        setTextInput(null);
        return;
      }
      const newElement: AnnotationElement = {
        type: "text",
        x: textInput.x,
        y: textInput.y,
        w: textInput.w,
        h: textInput.h,
        text: text.trim(),
        color: colorRef.current,
        fontSize: 0.02,
      };
      setElements((prev) => [...prev, newElement]);
      setTextInput(null);
    },
    [textInput],
  );

  const cancelText = useCallback(() => {
    setTextInput(null);
  }, []);

  return {
    tool,
    setTool,
    color,
    setColor,
    lineWidth,
    setLineWidth,
    elements,
    undo,
    clear,
    isEmpty: elements.length === 0,
    textInput,
    commitText,
    cancelText,
  };
}
